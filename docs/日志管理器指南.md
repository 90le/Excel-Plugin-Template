# 📝 插件日志管理器完整指南

## 🎯 概述

DTI_Tool.AddIn 框架通过 `IHostApplication` 接口为插件提供了统一的日志管理功能。插件可以通过此接口记录各种级别的日志信息，进行性能测量，并与宿主应用的日志系统完全集成。

## 🔌 IHostApplication 日志接口

### 接口定义

`IHostApplication` 接口提供了以下日志相关方法：

```csharp
public interface IHostApplication
{
    // 基础日志记录方法
    void LogDebug(string pluginName, string message);
    void LogInfo(string pluginName, string message);
    void LogWarning(string pluginName, string message);
    void LogError(string pluginName, string message);
    void LogError(string pluginName, Exception exception, string message);
    
    // 格式化日志记录方法
    void LogDebugFormat(string pluginName, string format, params object[] args);
    void LogInfoFormat(string pluginName, string format, params object[] args);
    void LogWarningFormat(string pluginName, string format, params object[] args);
    void LogErrorFormat(string pluginName, string format, params object[] args);
    void LogErrorFormat(string pluginName, Exception exception, string format, params object[] args);
    
    // 日志级别检查属性
    bool IsDebugEnabled { get; }
    bool IsInfoEnabled { get; }
    bool IsWarningEnabled { get; }
    bool IsErrorEnabled { get; }
    
    // 性能测量方法
    IDisposable StartPerformanceMeasure(string pluginName, string operationName);
    
    // 其他宿主功能...
}
```

### 核心特性

- ✅ **插件标识**: 每个日志记录都会自动标识来源插件
- ✅ **统一管理**: 所有插件日志统一到宿主的日志查看器
- ✅ **实时监控**: 支持实时查看和过滤插件日志
- ✅ **性能测量**: 内置高精度性能测量功能
- ✅ **异常处理**: 完整的异常信息记录和上下文保存

## 🚀 快速开始

### 1. 获取宿主应用接口

在插件的 `Initialize` 方法中，宿主应用会自动传递 `IHostApplication` 接口：

```csharp
public class MyExcelPlugin : IPlugin
{
    private IHostApplication _hostApplication;
    
    public void Initialize()
    {
        // _hostApplication 在此时已经可用
        _hostApplication.LogInfo(Name, "插件开始初始化");
        
        try
        {
            // 初始化代码...
            
            _hostApplication.LogInfo(Name, "插件初始化成功");
        }
        catch (Exception ex)
        {
            _hostApplication.LogError(Name, ex, "插件初始化失败");
            throw;
        }
    }
}
```

### 2. 基本日志记录

```csharp
public void MyFeature()
{
    // 记录调试信息
    _hostApplication.LogDebug(Name, "开始执行用户功能");
    
    // 记录一般信息
    _hostApplication.LogInfo(Name, "用户执行了 MyFeature 功能");
    
    // 记录警告信息
    if (someCondition)
    {
        _hostApplication.LogWarning(Name, "检测到潜在问题，但继续执行");
    }
    
    // 记录错误信息
    try
    {
        // 业务逻辑
    }
    catch (Exception ex)
    {
        _hostApplication.LogError(Name, ex, "功能执行失败");
        throw;
    }
}
```

### 3. 格式化日志记录

```csharp
public void ProcessData(int totalRows)
{
    // 使用格式化方法记录日志，性能更好
    _hostApplication.LogInfoFormat(Name, "开始处理数据，总行数: {0}", totalRows);
    
    int processed = 0;
    int errors = 0;
    
    for (int i = 0; i < totalRows; i++)
    {
        try
        {
            ProcessRow(i);
            processed++;
            
            // 定期报告进度
            if (i % 1000 == 0)
            {
                _hostApplication.LogDebugFormat(Name, "处理进度: {0}/{1} ({2:P1})", 
                    i, totalRows, (double)i / totalRows);
            }
        }
        catch (Exception ex)
        {
            errors++;
            _hostApplication.LogErrorFormat(Name, ex, "处理第 {0} 行时发生错误", i + 1);
        }
    }
    
    _hostApplication.LogInfoFormat(Name, "数据处理完成 - 成功: {0}, 失败: {1}", processed, errors);
}
```

### 4. 条件日志记录

```csharp
public void DetailedOperation()
{
    // 检查日志级别避免不必要的字符串操作
    if (_hostApplication.IsDebugEnabled)
    {
        var complexData = GenerateComplexDebugInfo(); // 只在需要时生成
        _hostApplication.LogDebugFormat(Name, "详细调试信息: {0}", complexData);
    }
    
    // 对于简单消息可以直接记录
    _hostApplication.LogInfo(Name, "执行详细操作");
}
```

### 5. 性能测量

```csharp
public void ProcessLargeData()
{
    using (_hostApplication.StartPerformanceMeasure(Name, "大数据处理"))
    {
        // 需要测量性能的代码
        for (int i = 0; i < 10000; i++)
        {
            ProcessDataItem(i);
        }
    }
    // 性能测量会自动记录到日志中
}
```

## 📊 日志级别详解

### 🔍 Debug - 调试信息

**用途**: 详细的调试信息，仅在开发调试时使用

**示例**:
```csharp
_hostApplication.LogDebug(Name, $"处理单元格 {cellAddress}，当前值: {cellValue}");
_hostApplication.LogDebug(Name, $"遍历工作表，当前索引: {index}/{total}");
```

**特点**:
- 生产环境中可能被过滤
- 包含详细的程序执行状态
- 有助于问题定位和程序理解

### ℹ️ Info - 一般信息

**用途**: 记录重要的操作和状态变化

**示例**:
```csharp
_hostApplication.LogInfo(Name, "开始导入 Excel 文件");
_hostApplication.LogInfo(Name, $"成功处理 {processedCount} 条记录");
_hostApplication.LogInfo(Name, "用户触发了数据导出功能");
```

**特点**:
- 记录关键业务操作
- 用于审计和操作跟踪
- 正常运行时的主要日志级别

### ⚠️ Warning - 警告信息

**用途**: 记录需要注意但不影响正常运行的问题

**示例**:
```csharp
_hostApplication.LogWarning(Name, "配置文件缺失，使用默认配置");
_hostApplication.LogWarning(Name, $"发现 {invalidCount} 个无效数据，已跳过");
_hostApplication.LogWarning(Name, "检测到内存使用率较高: 85%");
```

**特点**:
- 标识潜在问题
- 不中断程序执行
- 需要后续关注或处理

### ❌ Error - 错误信息

**用途**: 记录影响功能正常运行的错误

**示例**:
```csharp
// 简单错误信息
_hostApplication.LogError(Name, "文件保存失败，磁盘空间不足");

// 带异常的错误信息
try
{
    ProcessData();
}
catch (Exception ex)
{
    _hostApplication.LogError(Name, ex, "数据处理过程中发生异常");
}
```

**特点**:
- 记录完整的异常信息和堆栈跟踪
- 包含错误上下文信息
- 需要立即关注和处理

## ⏱️ 性能测量详解

### 基本用法

```csharp
using (_hostApplication.StartPerformanceMeasure(Name, "操作名称"))
{
    // 需要测量的代码
}
```

### 嵌套测量

```csharp
using (_hostApplication.StartPerformanceMeasure(Name, "完整流程"))
{
    using (_hostApplication.StartPerformanceMeasure(Name, "数据验证"))
    {
        ValidateData();
    }
    
    using (_hostApplication.StartPerformanceMeasure(Name, "数据处理"))
    {
        ProcessData();
    }
    
    using (_hostApplication.StartPerformanceMeasure(Name, "结果输出"))
    {
        OutputResults();
    }
}
```

### 测量结果

性能测量结果会自动记录到日志中：

```
[INFO] 完成执行: 数据验证, 耗时: 156ms
[INFO] 完成执行: 数据处理, 耗时: 2.3s
[INFO] 完成执行: 结果输出, 耗时: 89ms
[INFO] 完成执行: 完整流程, 耗时: 2.6s
```

## 🏗️ 最佳实践

### 1. 日志记录策略

```csharp
public class DataProcessor
{
    private readonly IHostApplication _hostApplication;
    private readonly string _pluginName;
    
    public DataProcessor(IHostApplication hostApplication, string pluginName)
    {
        _hostApplication = hostApplication;
        _pluginName = pluginName;
    }
    
    public void ProcessExcelData(Excel.Workbook workbook)
    {
        // 记录操作开始
        _hostApplication.LogInfo(_pluginName, $"开始处理工作簿: {workbook.Name}");
        
        try
        {
            using (_hostApplication.StartPerformanceMeasure(_pluginName, "Excel数据处理"))
            {
                foreach (Excel.Worksheet sheet in workbook.Worksheets)
                {
                    ProcessWorksheet(sheet);
                }
            }
            
            _hostApplication.LogInfo(_pluginName, "数据处理完成");
        }
        catch (Exception ex)
        {
            _hostApplication.LogError(_pluginName, ex, "数据处理失败");
            throw;
        }
    }
    
    private void ProcessWorksheet(Excel.Worksheet sheet)
    {
        _hostApplication.LogDebug(_pluginName, $"开始处理工作表: {sheet.Name}");
        
        var usedRange = sheet.UsedRange;
        if (usedRange == null)
        {
            _hostApplication.LogWarning(_pluginName, $"工作表 '{sheet.Name}' 没有数据");
            return;
        }
        
        _hostApplication.LogInfo(_pluginName, 
            $"处理工作表 '{sheet.Name}', 范围: {usedRange.Address}");
        
        // 处理逻辑...
    }
}
```

### 2. 错误处理模式

```csharp
public void SafeOperation()
{
    try
    {
        _hostApplication.LogInfo(Name, "开始执行安全操作");
        
        // 可能失败的操作
        RiskyOperation();
        
        _hostApplication.LogInfo(Name, "安全操作执行成功");
    }
    catch (ArgumentException ex)
    {
        // 可预期的错误
        _hostApplication.LogWarning(Name, $"参数错误: {ex.Message}");
        throw new InvalidOperationException("操作参数不正确", ex);
    }
    catch (System.IO.IOException ex)
    {
        // 可恢复的错误
        _hostApplication.LogError(Name, ex, "文件操作失败，请检查文件权限");
        throw;
    }
    catch (Exception ex)
    {
        // 未预期的错误
        _hostApplication.LogError(Name, ex, "执行安全操作时发生未知错误");
        throw;
    }
}
```

### 3. 格式化日志的性能优势

```csharp
// ✅ 推荐：使用Format方法，性能最佳
_hostApplication.LogInfoFormat(Name, "处理了 {0} 条记录，成功: {1}, 失败: {2}", count, success, failed);
_hostApplication.LogDebugFormat(Name, "当前进度: {0}/{1} ({2:P1})", current, total, (double)current / total);

// ✅ 可接受：使用字符串插值，性能良好
_hostApplication.LogInfo(Name, $"处理了 {count} 条记录，成功: {success}, 失败: {failed}");

// ❌ 避免：字符串连接，性能较差
_hostApplication.LogInfo(Name, "处理了" + count + "条记录"); 
```

### 4. 条件日志记录优化

```csharp
// ✅ 推荐：复杂调试信息使用条件检查
if (_hostApplication.IsDebugEnabled)
{
    var complexInfo = BuildComplexDebugInfo(); // 只在需要时执行
    _hostApplication.LogDebugFormat(Name, "复杂调试信息: {0}", complexInfo);
}

// ✅ 推荐：简单消息直接记录
_hostApplication.LogInfo(Name, "操作开始");

// ❌ 避免：不必要的条件检查
if (_hostApplication.IsInfoEnabled) // Info级别通常总是启用的
{
    _hostApplication.LogInfo(Name, "简单消息");
}
```

### 5. 避免过度日志记录

```csharp
// ❌ 避免在循环中过度记录
for (int i = 0; i < 10000; i++)
{
    _hostApplication.LogDebug(Name, $"处理第 {i} 项"); // 会产生大量日志
}

// ✅ 推荐的做法
_hostApplication.LogInfo(Name, $"开始处理 {totalCount} 个项目");
for (int i = 0; i < totalCount; i++)
{
    ProcessItem(i);
    
    // 定期报告进度
    if (i % 1000 == 0)
    {
        _hostApplication.LogDebug(Name, $"已处理 {i}/{totalCount} 项");
    }
}
_hostApplication.LogInfo(Name, $"处理完成，成功: {successCount}, 失败: {failCount}");
```

## 🔍 日志查看和监控

### 在宿主应用中查看日志

1. **打开日志查看器**:
   - 在 Excel 功能区找到 "DTI Tool"
   - 点击 "调试工具" 组中的 "日志查看器"

2. **过滤插件日志**:
   - 在插件过滤器中选择您的插件名称
   - 只显示来自该插件的日志记录

3. **级别过滤**:
   - 选择要查看的日志级别
   - 专注于 Error 和 Warning 级别进行问题诊断

4. **搜索功能**:
   - 使用搜索框查找特定的操作或错误
   - 支持正则表达式搜索

### 日志输出示例

```
[2024-01-15 14:30:15.123] [INFO] [BasePlugin] 插件初始化成功
[2024-01-15 14:30:18.456] [DEBUG] [BasePlugin] 开始处理工作表: Sheet1
[2024-01-15 14:30:20.789] [WARNING] [BasePlugin] 发现 3 个空单元格，已跳过
[2024-01-15 14:30:22.101] [INFO] [BasePlugin] 完成执行: 数据处理, 耗时: 1.5s
[2024-01-15 14:30:25.234] [ERROR] [BasePlugin] 文件保存失败
Exception: System.IO.IOException
Message: 磁盘空间不足
StackTrace: at System.IO.File.WriteAllText(...)
```

## 🚨 故障排除

### 常见问题

**Q: 为什么我的日志没有显示？**

A: 检查以下几点：
- 确保使用正确的插件名称
- 检查日志级别过滤设置
- 确认宿主应用的日志功能已启用

**Q: 性能测量显示的时间不准确？**

A: 确保：
- 正确使用 `using` 语句
- 不要在测量代码中包含UI操作
- 避免嵌套过深的性能测量

**Q: 异常信息不完整？**

A: 使用带异常参数的重载方法：
```csharp
catch (Exception ex)
{
    _hostApplication.LogError(Name, ex, "操作失败");  // ✅ 正确
    // 而不是
    _hostApplication.LogError(Name, ex.Message);      // ❌ 信息不完整
}
```

### 调试技巧

1. **使用分级日志**: 开发时使用 Debug 级别，生产时使用 Info 级别
2. **添加上下文**: 在日志中包含操作的上下文信息
3. **性能监控**: 对关键操作进行性能测量
4. **异常链**: 保持异常的完整调用链

## 📚 完整示例

```csharp
using System;
using DTI_Tool.AddIn.Common.Interfaces;
using Excel = Microsoft.Office.Interop.Excel;

public class ExcelDataImporter
{
    private readonly IHostApplication _hostApplication;
    private readonly string _pluginName;
    
    public ExcelDataImporter(IHostApplication hostApplication, string pluginName)
    {
        _hostApplication = hostApplication ?? throw new ArgumentNullException(nameof(hostApplication));
        _pluginName = pluginName;
    }
    
    public void ImportData(string filePath)
    {
        _hostApplication.LogInfoFormat(_pluginName, "开始导入数据文件: {0}", filePath);
        
        using (_hostApplication.StartPerformanceMeasure(_pluginName, "数据导入"))
        {
            try
            {
                                 if (!System.IO.File.Exists(filePath))
                 {
                     _hostApplication.LogWarningFormat(_pluginName, "文件不存在: {0}", filePath);
                     return;
                 }
                
                var excelApp = _hostApplication.ExcelApplication;
                Excel.Workbook workbook = null;
                
                try
                {
                    using (_hostApplication.StartPerformanceMeasure(_pluginName, "打开工作簿"))
                    {
                        workbook = excelApp.Workbooks.Open(filePath);
                    }
                    
                                         if (_hostApplication.IsDebugEnabled)
                     {
                         _hostApplication.LogDebugFormat(_pluginName, "成功打开工作簿: {0}", workbook.Name);
                     }
                     
                     ProcessWorkbook(workbook);
                     
                     _hostApplication.LogInfo(_pluginName, "数据导入完成");
                }
                finally
                {
                    if (workbook != null)
                    {
                        workbook.Close(false);
                        _hostApplication.LogDebug(_pluginName, "已关闭工作簿");
                    }
                }
            }
                         catch (Exception ex)
             {
                 _hostApplication.LogErrorFormat(_pluginName, ex, "数据导入失败: {0}", filePath);
                 throw;
             }
        }
    }
    
    private void ProcessWorkbook(Excel.Workbook workbook)
    {
        using (_hostApplication.StartPerformanceMeasure(_pluginName, "处理工作簿"))
        {
            foreach (Excel.Worksheet sheet in workbook.Worksheets)
            {
                ProcessWorksheet(sheet);
            }
        }
    }
    
    private void ProcessWorksheet(Excel.Worksheet sheet)
    {
        using (_hostApplication.StartPerformanceMeasure(_pluginName, $"处理工作表 {sheet.Name}"))
        {
                     if (_hostApplication.IsDebugEnabled)
         {
             _hostApplication.LogDebugFormat(_pluginName, "开始处理工作表: {0}", sheet.Name);
         }
         
         var usedRange = sheet.UsedRange;
         if (usedRange == null)
         {
             _hostApplication.LogWarningFormat(_pluginName, "工作表 '{0}' 没有数据", sheet.Name);
             return;
         }
         
         _hostApplication.LogInfoFormat(_pluginName, 
             "工作表 '{0}' 数据范围: {1}, 行数: {2}, 列数: {3}",
             sheet.Name, usedRange.Address, usedRange.Rows.Count, usedRange.Columns.Count);
            
            try
            {
                var values = usedRange.Value2;
                if (values != null)
                {
                    ProcessData(values);
                }
            }
                         catch (Exception ex)
             {
                 _hostApplication.LogErrorFormat(_pluginName, ex, "处理工作表 '{0}' 时发生错误", sheet.Name);
                 throw;
             }
        }
    }
    
    private void ProcessData(object[,] data)
    {
        // 数据处理逻辑
        _hostApplication.LogDebug(_pluginName, "开始处理数据数组");
        
        // 处理逻辑...
        
        _hostApplication.LogDebug(_pluginName, "数据处理完成");
    }
}
```

---

通过遵循本指南，您可以充分利用 DTI_Tool.AddIn 框架的日志管理功能，构建出可维护、可监控的高质量 Excel 插件。

💡 **提示**: 结合 [日志使用指南](LOGGING_USAGE.md) 和 [日志测试功能指南](LOGGING_TEST_FEATURES.md) 一起阅读，获得更全面的理解。 